# R5: 前沿RAG技术与智能体应用 🧠

## 🎯 模块核心目标

本模块的核心目标是**将学术界和工业界最前沿的RAG研究成果，转化为可运行、可实践的代码**。我们将超越传统的“检索-生成”范式，探索如何通过知识图谱、自我反思、多代理协作等技术，赋予RAG系统更强的**推理能力、规划能力和决策能力**，使其在处理复杂、多跳问题时，表现得更像一个真正的领域专家。

## 🧠 核心概念

1.  **结构化与非结构化知识的融合 (Structured + Unstructured Knowledge):** 真实世界的知识，一部分是非结构化的文本，另一部分是结构化的实体和关系。将两者结合，能极大提升推理的准确性。
2.  **自我反思与迭代 (Self-Correction & Iteration):** 人类专家在解决问题时，会不断地反思自己的答案是否正确、信息是否足够。顶级的RAG系统也应该具备这种“自我校正”的能力。
3.  **从链到图 (From Chains to Graphs):** 简单的线性工作流（Chain）无法处理需要条件判断、循环和动态决策的复杂任务。我们需要一种更强大的流程编排方式——**计算图（Graph）**。
4.  **智能体即流程 (Agent as a Process):** Agent的本质不是一次性的调用，而是一个持续运行的、能够自主规划和执行任务的智能流程。

## 🛠️ 技术栈与工具

*   **图数据库:** `Neo4j`
*   **图计算与编排:** `LangGraph`
*   **前沿RAG框架:** (可能需要直接阅读论文并自行实现部分逻辑)
*   **核心框架:** (复用) `LangChain`, `LlamaIndex`

---

## 🚀 行动计划：构建一个会思考的AI

### **步骤一：知识图谱增强RAG (Graph RAG)**

让RAG学会“顺藤摸瓜”。

*   [ ] **5.1. 学习知识图谱基础:**
    *   **学习思想:** 了解知识图谱的基本构成（节点Node、关系Edge、属性Property）。学习Cypher查询语言的基础（类似于SQL，但用于图查询）。
    *   **实践任务:** 安装Neo4j数据库。手动创建几个节点（如：“穆芳铭”, “上海第二工业大学”）和关系（如 `[:就读于]`），并用Cypher进行简单的查询。

*   [ ] **5.2. 从文本自动构建知识图谱:**
    *   **学习思想:** 利用LLM强大的信息提取能力，从一段非结构化的文本中，自动识别出实体、关系，并将其结构化地存入知识图谱。
    *   **实践任务:** 编写一个Chain，输入一段文本（例如你的项目介绍），输出一系列可以创建图谱的Cypher语句。然后执行这些语句，将文本内容存入Neo4j。

*   [ ] **5.3. 实现知识图谱与向量检索的混合RAG:**
    *   **实践任务:** 构建一个更智能的RAG流程。当用户提问时：
        1.  先用LLM判断这个问题更适合用**向量检索**（回答事实性、描述性问题）还是**图谱查询**（回答关于实体间关系、多跳推理的问题）。
        2.  根据判断结果，调用相应的检索器。
        3.  **进阶:** 将两种检索结果融合后，再送入LLM生成最终答案。

### **步骤二：自我反思RAG (Self-Correcting RAG / Self-RAG)**

让RAG学会“三思而后行”。

*   [ ] **5.4. 学习Self-RAG论文核心思想:**
    *   **学习思想:** 阅读Self-RAG论文的摘要和核心图示。理解它的核心是在RAG的各个环节加入了“反思令牌”（Reflection Token）。例如，在检索前，先判断“是否有必要检索？”；在生成后，再判断“生成的答案是否有幻觉？”、“答案是否完全被上下文支持？”。

*   [ ] **5.5. 实践一个简化的自我修正循环:**
    *   **实践任务:** 改造你现有的RAG流程，加入一个“生成后验证”的步骤（我们在`R3`中已初步探索）。
        1.  RAG系统生成一个初步答案。
        2.  启动一个新的LLM调用（“反思”步骤），它的输入是“上下文”和“初步答案”，它的Prompt是：“请严格依据<上下文>，评估<初步答案>的正确性。如果答案有错误或幻觉，请直接修正它。如果答案正确，则无需修改。”
        3.  将修正后的答案作为最终输出。

### **步骤三：掌握终极武器——LangGraph**

从“链式思维”升级到“图状思维”。

*   [ ] **5.6. 学习LangGraph的核心概念:**
    *   **学习思想:** 阅读LangGraph的官方文档。理解它的核心是**将应用定义为一个状态图（State Graph）**。图中有多个**节点（Nodes）**，每个节点代表一个处理步骤（一个函数或一个Chain）。节点之间由**边（Edges）**连接，这些边可以是**条件性的**，由一个LLM来决定下一步该走向哪个节点。
    *   **关键概念:** `StatefulGraph`, `add_node`, `add_edge`, `add_conditional_edges`, `set_entry_point`, `set_finish_point`。

*   [ ] **5.7. 用LangGraph重构你的Agent:**
    *   **实践任务:** 将你在`R0`或`W4`中用标准Agent框架（如ReAct）构建的Agent，**用LangGraph重新实现**。
    *   **目标:** 你会发现，用LangGraph可以更清晰、更可控地定义Agent的每一个决策点和循环过程。例如，当工具执行失败时，你可以明确地定义一个“重试”或“求助”的节点。

*   [ ] **5.8. 构建一个复杂的多智能体协作系统 (Multi-Agent System):**
    *   **【终极挑战】** 使用LangGraph，设计一个包含多个Agent的协作系统。例如：
        1.  **一个“任务分派Agent”**：接收总任务，并将其拆解给其他Agent。
        2.  **一个“信息搜集Agent”**：负责使用搜索工具上网查资料。
        3.  **一个“数据分析Agent”**：负责处理和分析搜集到的信息。
        4.  **一个“报告生成Agent”**：负责将分析结果整合成最终报告。
    *   这些Agent在一个`StatefulGraph`中协同工作，由一个“总管”（Router）来决定任务的流向。

---

## ✅ 最终产出

当你完成本模块所有任务后，你的`R5/`文件夹下应该包含：

1.  `graph_rag/`: 一个包含知识图谱构建与查询代码的子项目。
2.  `self_rag_demo.py`: 一个实现了简化版自我修正功能的RAG脚本。
3.  `langgraph_agent/`: 一个使用LangGraph重构的、结构更清晰的Agent项目。
4.  `(Optional) multi_agent_system/`: 你的多智能体协作系统项目，这将是你简历上最闪亮的星。
5.  `ADVANCED_RAG_REPORT.md`: 一份详细的报告文档，包含：
    *   你对Graph RAG、Self-RAG等前沿技术的理解和思考。
    *   展示你用LangGraph绘制的复杂Agent流程图。
    *   分享你在构建这些高级系统时，遇到的最大挑战，以及你对未来RAG发展的看法。

## 🚀 下一步

你现在已经站在了AIGC应用领域的技术最前沿。然而，一个好的应用不仅要聪明，还要**快、要稳、要省钱**。准备进入 **`R6: 系统性能与架构优化`** 阶段，学习如何将你的“智能大脑”装上一个“高性能的引擎”，让它能服务于成千上万的用户。